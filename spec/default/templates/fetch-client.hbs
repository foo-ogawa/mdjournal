/**
 * Auto-generated API Client from OpenAPI specification
 * Generated from: {{title}} v{{version}}
 * 
 * ⚠️ DO NOT EDIT MANUALLY - Generated by micro-contracts
 * @generated
 * 
 * Client API matches Service API signature (single input object).
 * Internally maps input to HTTP request (path params, query params, body).
 */

import type {
{{#each services}}
  {{name}}ServiceApi,
{{/each}}
} from '{{contractPackage}}/services/index.js';
import type {
{{#each schemaTypes}}
  {{this}},
{{/each}}
} from '{{contractPackage}}/schemas/types.js';

// BASE_URL derived from OpenAPI servers[0].url: {{baseUrl}}
// Can be overridden via environment variable (Vite: VITE_API_URL)
const BASE_URL = (typeof import.meta !== 'undefined' && import.meta.env?.VITE_API_URL) || '{{baseUrl}}';

// ========================================
// API Error Class
// ========================================

export class ApiError extends Error {
  status: number;
  code?: string;
  
  constructor(status: number, message: string, code?: string) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
    this.code = code;
  }
}

// ========================================
// Fetch Helper
// ========================================

async function handleResponse<T>(res: Response): Promise<T> {
  if (!res.ok) {
    const errorBody = await res.json().catch(() => ({ message: 'API Error' }));
    throw new ApiError(
      res.status,
      errorBody.message || `HTTP ${res.status}`,
      errorBody.code
    );
  }
  // Handle 204 No Content and empty responses
  if (res.status === 204 || res.headers.get('content-length') === '0') {
    return undefined as T;
  }
  return res.json();
}

// ========================================
// API Clients (Service-aligned)
// ========================================

{{#each services}}
/**
 * {{name}} API Client
 */
export const {{key}}Api: {{name}}ServiceApi = {
{{#each ../routes}}
{{#if (eq service ../name)}}
  /**
   * {{httpMethod}} {{path}}
   {{#if summary}}* {{summary}}{{/if}}
   */
  async {{serviceMethod}}({{#if (or pathParams.length queryParams.length requestBody)}}input{{else}}_input{{/if}}: {{inputType}}): Promise<{{responseType}}> {
{{#if queryParams.length}}
    const searchParams = new URLSearchParams();
{{#each queryParams}}
    if (input.{{name}} !== undefined) searchParams.set('{{name}}', String(input.{{name}}));
{{/each}}
{{/if}}
{{#if pathParams.length}}
    const url = `${BASE_URL}{{clientUrlPatternInput}}`{{#if queryParams.length}} + (searchParams.toString() ? '?' + searchParams : ''){{/if}};
{{else}}
    const url = `${BASE_URL}{{path}}`{{#if queryParams.length}} + (searchParams.toString() ? '?' + searchParams : ''){{/if}};
{{/if}}
{{#if (eq httpMethod "GET")}}
    const res = await fetch(url);
{{else if requestBody}}
    const res = await fetch(url, {
      method: '{{httpMethod}}',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(input.data),
    });
{{else}}
    const res = await fetch(url, { method: '{{httpMethod}}' });
{{/if}}
{{#if (eq responseType "void")}}
    await handleResponse<void>(res);
{{else}}
    return handleResponse<{{responseType}}>(res);
{{/if}}
  },

{{/if}}
{{/each}}
};

{{/each}}

// ========================================
// Re-export types for convenience
// ========================================

export type {
{{#each schemaTypes}}
  {{this}},
{{/each}}
};
