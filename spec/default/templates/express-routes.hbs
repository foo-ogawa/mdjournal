/**
 * Auto-generated Express.js routes
 * Generated from: {{title}} v{{version}}
 * 
 * ⚠️ DO NOT EDIT MANUALLY - Generated by micro-contracts
 * @generated
 */

import { Router, Request, Response, NextFunction } from 'express';
import type {
{{#each schemaTypes}}
  {{this}},
{{/each}}
} from '{{contractPackage}}/schemas/types.js';
{{#each services}}
import type { {{name}}ServiceApi } from '{{../contractPackage}}/services/{{name}}ServiceApi.js';
{{/each}}

// ========================================
// Service Dependencies
// ========================================

{{#each services}}
let {{key}}Service: {{name}}ServiceApi;
{{/each}}

/**
 * Initialize service instances
 */
export function initServices(services: {
{{#each services}}
  {{key}}: {{name}}ServiceApi;
{{/each}}
}): void {
{{#each services}}
  {{key}}Service = services.{{key}};
{{/each}}
}

// ========================================
// Express Router
// ========================================

const router = Router();

/**
 * Async handler wrapper to catch errors
 */
function asyncHandler(
  fn: (req: Request, res: Response, next: NextFunction) => Promise<void>
): (req: Request, res: Response, next: NextFunction) => void {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

// ========================================
// Route Handlers
// ========================================

{{#each routes}}
/**
 * {{httpMethod}} {{path}}
 * {{summary}}
 * operationId: {{operationId}}
 */
router.{{method}}('{{fastifyPath}}', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - service handles type coercion
  const input = {
{{#each pathParams}}
    {{name}}: req.params.{{name}},
{{/each}}
{{#each queryParams}}
    {{name}}: req.query.{{name}},
{{/each}}
{{#if requestBody}}
    data: req.body as {{requestBody.schemaName}},
{{/if}}
  } as unknown as {{inputType}};

  try {
{{#if (eq responseType "void")}}
    await {{serviceKey}}Service.{{serviceMethod}}(input);
    res.status(204).send();
{{else}}
    const result = await {{serviceKey}}Service.{{serviceMethod}}(input);
    res.json(result);
{{/if}}
  } catch (error) {
    // Handle service-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

{{/each}}

export default router;

/**
 * Register routes with Express app
 */
export function registerRoutes(app: Router, basePath: string = '/api'): void {
{{#each services}}
  if (!{{key}}Service) {
    throw new Error('{{name}}Service is not initialized. Call initServices() first.');
  }
{{/each}}
  app.use(basePath, router);
}
