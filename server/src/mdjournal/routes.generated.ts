/**
 * Auto-generated Express.js routes
 * Generated from: mdJournal API v1.0.0
 * 
 * ⚠️ DO NOT EDIT MANUALLY - Generated by micro-contracts
 * @generated
 */

import { Router, Request, Response, NextFunction } from 'express';
import type {
  CalendarData,
  Calendar_getAvailableYearMonthsInput,
  Calendar_getCalendarDataInput,
  Calendar_getCalendarDataParams,
  Config,
  Config_getConfigInput,
  Config_getRoutinesMarkdownInput,
  Config_saveRoutinesMarkdownInput,
  Config_updateConfigInput,
  Error,
  ExtendedGitStatus,
  Git_getStatusInput,
  ProblemDetails,
  ReportResponse,
  ReportSaveRequest,
  ReportSaveResponse,
  Report_deleteReportInput,
  Report_deleteReportParams,
  Report_getReportInput,
  Report_getReportParams,
  Report_saveReportInput,
  Report_saveReportParams,
  RoutinesMarkdownRequest,
  RoutinesMarkdownResponse,
  YearMonthsResponse,
} from '@mdjournal/contract/schemas/types.js';
import type { CalendarApi } from '@mdjournal/contract/domains/CalendarApi.js';
import type { ConfigApi } from '@mdjournal/contract/domains/ConfigApi.js';
import type { GitApi } from '@mdjournal/contract/domains/GitApi.js';
import type { ReportApi } from '@mdjournal/contract/domains/ReportApi.js';

// ========================================
// Domain Dependencies
// ========================================

let calendarDomain: CalendarApi;
let configDomain: ConfigApi;
let gitDomain: GitApi;
let reportDomain: ReportApi;

/**
 * Initialize domain instances
 */
export function initDomains(domains: {
  calendar: CalendarApi;
  config: ConfigApi;
  git: GitApi;
  report: ReportApi;
}): void {
  calendarDomain = domains.calendar;
  configDomain = domains.config;
  gitDomain = domains.git;
  reportDomain = domains.report;
}

// ========================================
// Express Router
// ========================================

const router = Router();

/**
 * Async handler wrapper to catch errors
 */
function asyncHandler(
  fn: (req: Request, res: Response, next: NextFunction) => Promise<void>
): (req: Request, res: Response, next: NextFunction) => void {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

// ========================================
// Route Handlers
// ========================================

/**
 * GET /reports/{date}
 * 日報取得
 * operationId: getReport
 */
router.get('/reports/:date', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - domain handles type coercion
  const input = {
    date: req.params.date,
  } as unknown as Report_getReportInput;

  try {
    const result = await reportDomain.getReport(input);
    res.json(result);
  } catch (error) {
    // Handle domain-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * PUT /reports/{date}
 * 日報保存
 * operationId: saveReport
 */
router.put('/reports/:date', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - domain handles type coercion
  const input = {
    date: req.params.date,
    data: req.body as ReportSaveRequest,
  } as unknown as Report_saveReportInput;

  try {
    const result = await reportDomain.saveReport(input);
    res.json(result);
  } catch (error) {
    // Handle domain-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * DELETE /reports/{date}
 * 日報削除
 * operationId: deleteReport
 */
router.delete('/reports/:date', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - domain handles type coercion
  const input = {
    date: req.params.date,
  } as unknown as Report_deleteReportInput;

  try {
    await reportDomain.deleteReport(input);
    res.status(204).send();
  } catch (error) {
    // Handle domain-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * GET /calendar
 * カレンダー用集計データ取得
 * operationId: getCalendarData
 */
router.get('/calendar', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - domain handles type coercion
  const input = {
    year: req.query.year,
    month: req.query.month,
  } as unknown as Calendar_getCalendarDataInput;

  try {
    const result = await calendarDomain.getCalendarData(input);
    res.json(result);
  } catch (error) {
    // Handle domain-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * GET /calendar/months
 * 日報が存在する年月リスト取得
 * operationId: getAvailableYearMonths
 */
router.get('/calendar/months', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - domain handles type coercion
  const input = {
  } as unknown as Calendar_getAvailableYearMonthsInput;

  try {
    const result = await calendarDomain.getAvailableYearMonths(input);
    res.json(result);
  } catch (error) {
    // Handle domain-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * GET /config
 * 設定取得
 * operationId: getConfig
 */
router.get('/config', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - domain handles type coercion
  const input = {
  } as unknown as Config_getConfigInput;

  try {
    const result = await configDomain.getConfig(input);
    res.json(result);
  } catch (error) {
    // Handle domain-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * PUT /config
 * 設定更新
 * operationId: updateConfig
 */
router.put('/config', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - domain handles type coercion
  const input = {
    data: req.body as Config,
  } as unknown as Config_updateConfigInput;

  try {
    const result = await configDomain.updateConfig(input);
    res.json(result);
  } catch (error) {
    // Handle domain-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * GET /config/routines/markdown
 * ルーチン設定をMarkdown形式で取得
 * operationId: getRoutinesMarkdown
 */
router.get('/config/routines/markdown', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - domain handles type coercion
  const input = {
  } as unknown as Config_getRoutinesMarkdownInput;

  try {
    const result = await configDomain.getRoutinesMarkdown(input);
    res.json(result);
  } catch (error) {
    // Handle domain-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * PUT /config/routines/markdown
 * ルーチン設定をMarkdown形式で保存
 * operationId: saveRoutinesMarkdown
 */
router.put('/config/routines/markdown', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - domain handles type coercion
  const input = {
    data: req.body as RoutinesMarkdownRequest,
  } as unknown as Config_saveRoutinesMarkdownInput;

  try {
    const result = await configDomain.saveRoutinesMarkdown(input);
    res.json(result);
  } catch (error) {
    // Handle domain-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * GET /git/status
 * Git状態取得
 * operationId: getGitStatus
 */
router.get('/git/status', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - domain handles type coercion
  const input = {
  } as unknown as Git_getStatusInput;

  try {
    const result = await gitDomain.getStatus(input);
    res.json(result);
  } catch (error) {
    // Handle domain-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));


export default router;

/**
 * Register routes with Express app
 */
export function registerRoutes(app: Router, basePath: string = '/api'): void {
  if (!calendarDomain) {
    throw new Error('CalendarDomain is not initialized. Call initDomains() first.');
  }
  if (!configDomain) {
    throw new Error('ConfigDomain is not initialized. Call initDomains() first.');
  }
  if (!gitDomain) {
    throw new Error('GitDomain is not initialized. Call initDomains() first.');
  }
  if (!reportDomain) {
    throw new Error('ReportDomain is not initialized. Call initDomains() first.');
  }
  app.use(basePath, router);
}
