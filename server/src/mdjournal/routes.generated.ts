/**
 * Auto-generated Express.js routes
 * Generated from: mdJournal API v1.0.0
 * 
 * ⚠️ DO NOT EDIT MANUALLY - Generated by micro-contracts
 * @generated
 */

import { Router, Request, Response, NextFunction } from 'express';
import type {
  CalendarData,
  Calendar_getAvailableYearMonthsInput,
  Calendar_getCalendarDataInput,
  Calendar_getCalendarDataParams,
  Config,
  Config_getConfigInput,
  Config_getRoutinesMarkdownInput,
  Config_saveRoutinesMarkdownInput,
  Config_updateConfigInput,
  Error,
  ExtendedGitStatus,
  Git_getStatusInput,
  ProblemDetails,
  ReportResponse,
  ReportSaveRequest,
  ReportSaveResponse,
  Report_deleteReportInput,
  Report_deleteReportParams,
  Report_getReportInput,
  Report_getReportParams,
  Report_saveReportInput,
  Report_saveReportParams,
  RoutinesMarkdownRequest,
  RoutinesMarkdownResponse,
  YearMonthsResponse,
} from '@mdjournal/contract/schemas/types.js';
import type { CalendarServiceApi } from '@mdjournal/contract/services/CalendarServiceApi.js';
import type { ConfigServiceApi } from '@mdjournal/contract/services/ConfigServiceApi.js';
import type { GitServiceApi } from '@mdjournal/contract/services/GitServiceApi.js';
import type { ReportServiceApi } from '@mdjournal/contract/services/ReportServiceApi.js';

// ========================================
// Service Dependencies
// ========================================

let calendarService: CalendarServiceApi;
let configService: ConfigServiceApi;
let gitService: GitServiceApi;
let reportService: ReportServiceApi;

/**
 * Initialize service instances
 */
export function initServices(services: {
  calendar: CalendarServiceApi;
  config: ConfigServiceApi;
  git: GitServiceApi;
  report: ReportServiceApi;
}): void {
  calendarService = services.calendar;
  configService = services.config;
  gitService = services.git;
  reportService = services.report;
}

// ========================================
// Express Router
// ========================================

const router = Router();

/**
 * Async handler wrapper to catch errors
 */
function asyncHandler(
  fn: (req: Request, res: Response, next: NextFunction) => Promise<void>
): (req: Request, res: Response, next: NextFunction) => void {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

// ========================================
// Route Handlers
// ========================================

/**
 * GET /reports/{date}
 * 日報取得
 * operationId: getReport
 */
router.get('/reports/:date', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - service handles type coercion
  const input = {
    date: req.params.date,
  } as unknown as Report_getReportInput;

  try {
    const result = await reportService.getReport(input);
    res.json(result);
  } catch (error) {
    // Handle service-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * PUT /reports/{date}
 * 日報保存
 * operationId: saveReport
 */
router.put('/reports/:date', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - service handles type coercion
  const input = {
    date: req.params.date,
    data: req.body as ReportSaveRequest,
  } as unknown as Report_saveReportInput;

  try {
    const result = await reportService.saveReport(input);
    res.json(result);
  } catch (error) {
    // Handle service-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * DELETE /reports/{date}
 * 日報削除
 * operationId: deleteReport
 */
router.delete('/reports/:date', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - service handles type coercion
  const input = {
    date: req.params.date,
  } as unknown as Report_deleteReportInput;

  try {
    await reportService.deleteReport(input);
    res.status(204).send();
  } catch (error) {
    // Handle service-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * GET /calendar
 * カレンダー用集計データ取得
 * operationId: getCalendarData
 */
router.get('/calendar', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - service handles type coercion
  const input = {
    year: req.query.year,
    month: req.query.month,
  } as unknown as Calendar_getCalendarDataInput;

  try {
    const result = await calendarService.getCalendarData(input);
    res.json(result);
  } catch (error) {
    // Handle service-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * GET /calendar/months
 * 日報が存在する年月リスト取得
 * operationId: getAvailableYearMonths
 */
router.get('/calendar/months', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - service handles type coercion
  const input = {
  } as unknown as Calendar_getAvailableYearMonthsInput;

  try {
    const result = await calendarService.getAvailableYearMonths(input);
    res.json(result);
  } catch (error) {
    // Handle service-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * GET /config
 * 設定取得
 * operationId: getConfig
 */
router.get('/config', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - service handles type coercion
  const input = {
  } as unknown as Config_getConfigInput;

  try {
    const result = await configService.getConfig(input);
    res.json(result);
  } catch (error) {
    // Handle service-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * PUT /config
 * 設定更新
 * operationId: updateConfig
 */
router.put('/config', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - service handles type coercion
  const input = {
    data: req.body as Config,
  } as unknown as Config_updateConfigInput;

  try {
    const result = await configService.updateConfig(input);
    res.json(result);
  } catch (error) {
    // Handle service-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * GET /config/routines/markdown
 * ルーチン設定をMarkdown形式で取得
 * operationId: getRoutinesMarkdown
 */
router.get('/config/routines/markdown', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - service handles type coercion
  const input = {
  } as unknown as Config_getRoutinesMarkdownInput;

  try {
    const result = await configService.getRoutinesMarkdown(input);
    res.json(result);
  } catch (error) {
    // Handle service-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * PUT /config/routines/markdown
 * ルーチン設定をMarkdown形式で保存
 * operationId: saveRoutinesMarkdown
 */
router.put('/config/routines/markdown', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - service handles type coercion
  const input = {
    data: req.body as RoutinesMarkdownRequest,
  } as unknown as Config_saveRoutinesMarkdownInput;

  try {
    const result = await configService.saveRoutinesMarkdown(input);
    res.json(result);
  } catch (error) {
    // Handle service-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));

/**
 * GET /git/status
 * Git状態取得
 * operationId: getGitStatus
 */
router.get('/git/status', asyncHandler(async (req: Request, res: Response) => {
  // Build input from request
  // Note: Query params are strings from HTTP - service handles type coercion
  const input = {
  } as unknown as Git_getStatusInput;

  try {
    const result = await gitService.getStatus(input);
    res.json(result);
  } catch (error) {
    // Handle service-specific errors by error name
    if (error instanceof Error) {
      const errorName = error.name;
      const errorCode = (error as { code?: string }).code;
      
      if (errorName === 'NotFoundError' || errorCode === 'NOT_FOUND') {
        res.status(404).json({ code: 'NOT_FOUND', message: error.message });
      } else if (errorName === 'ValidationError' || errorCode === 'INVALID_REQUEST') {
        res.status(400).json({ code: 'INVALID_REQUEST', message: error.message });
      } else {
        throw error;
      }
    } else {
      throw error;
    }
  }
}));


export default router;

/**
 * Register routes with Express app
 */
export function registerRoutes(app: Router, basePath: string = '/api'): void {
  if (!calendarService) {
    throw new Error('CalendarService is not initialized. Call initServices() first.');
  }
  if (!configService) {
    throw new Error('ConfigService is not initialized. Call initServices() first.');
  }
  if (!gitService) {
    throw new Error('GitService is not initialized. Call initServices() first.');
  }
  if (!reportService) {
    throw new Error('ReportService is not initialized. Call initServices() first.');
  }
  app.use(basePath, router);
}
